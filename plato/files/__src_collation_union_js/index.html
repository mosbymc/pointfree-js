<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - ./src/collation/union.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>./src/collation/union.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.81</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">160</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">24.00</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">0.10</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import { defaultEqualityComparer, memoizer2 } from &#039;../helpers&#039;;


/*
function union(previousFunc, collection, comparer) {
    comparer = comparer || defaultEqualityComparer;
    var havePreviouslyViewed = memoizer2(comparer),
        atEndOfList = false,
        atEndOfCollection = false;

    function unionFunc(item) {
        return havePreviouslyViewed(item);
    }

    return Object.defineProperty(
        //TODO: I don&#039;t know how realistic it would be to implement an ES6 generator for the .next function properties,
        //TODO: but it would allow me to throw the whole function into a while-loop with a .next() as the predicate.
        //TODO: The problem is that it takes so darn much to transpile/polyfill ES6 generators for a pre-ES6 environment
        //TODO: that it probably isn&#039;t realistic to use them. However, I may be able to simulate a generator with closures
        //TODO: that would allow a similar while-loop execution.
        unionFunc,
        &#039;next&#039;, {
            writable: false,
            configurable: false,
            value: function _next() {
                var next,
                    res;
                while (!atEndOfList &amp;&amp; undefined === res) {
                    next = previousFunc.next();
                    if (emptyObj.isPrototypeOf(next)) {
                        atEndOfList = true;
                        break;
                    }

                    res = unionFunc(next);
                    if (!res) return res;
                }

                while (!atEndOfCollection &amp;&amp; undefined === res) {
                    next = collection.shift();
                    if (!collection.length) atEndOfCollection = true;
                    res = unionFunc(next);
                    if (!res) return res;
                }
                return Object.create(emptyObj);
            }
        }
    )
}
*/

//TODO: Here&#039;s what I&#039;m thinking now.
//TODO: 1) I am going to stick with using ES2015 generators for queryable object evaluation. Even though that means transpiling them and including
//TODO:    the &#039;regeneratorRuntime&#039; if someone wants to use this library in a pre-ES2015 environment, it allows for a much cleaner and clearer
//TODO:    code path/syntax, a much simpler logic for iterating each item through each pipeline function, and ostensible allows for easier extensions
//TODO:    to be written for the queryable logic by consumers of the library.
//TODO:
//TODO: 2) Given #1, at some point I may try to make a more pre-ES2015-compliant version of this library that doesn&#039;t need to rely on the &#039;regeneratorRuntime&#039;
//TODO:    to properly function in a pre-ES2015 environment.
//TODO:
//TODO: 3) Using generators, it seems like all I need to do is define each queryable function (similar to what I have in the js-data-manager library),
//TODO:    and the generator/iterator for each function. The initial/base queryable object&#039;s iterator would always be the same: a for-of loop that yields
//TODO:    each item in the source collection. Every time a queryable method is chained off a queryable object, it will return a new queryable object
//TODO:    whose source is not the base collection, but rather the previous queryable object itself.
//TODO:
//TODO:    Each &#039;method&#039; that can be called on the queryable object and which results in deferred execution, should have its own iterator defined,
//TODO:    so that, in effect, each &#039;method&#039; knows how to iterate and evaluate itself. When creating the new queryable object to return from a &#039;method&#039;
//TODO:    call, that &#039;method&#039; should return its iterator to be set as the new queryable object&#039;s iterator; thus, every time a deferred execution &#039;method&#039;
//TODO:    is chained off a queryable, it results in a new queryable object that has a different iterator than the one that proceeded it and is unique
//TODO:    to the &#039;method&#039; that was called.
//TODO:
//TODO:    Since a queryable object will always have a [Symbol.iterator] property, they can be iterated in a for-of loop. And since the queryable&#039;s
//TODO:    iterator is a generator, they can gather as few or as many of the items from the &#039;source&#039; as needed before &#039;evaluating themselves&#039;. The one
//TODO:    potential problem I see is that, once a queryable pipeline has been built up by chaining &#039;methods&#039;, the evaluation of the final queryable
//TODO:    will cause all prior queryables to also be evaluated. To an extent this isn&#039;t an issue, since, even if it didn&#039;t cause the evaluation of the
//TODO:    previous queryable objects themselves, but instead it just sorta reduced each queryable&#039;s function over the source collection, the evaluation
//TODO:    would have to occur anyway... in other words, it wouldn&#039;t be performing any additional work by evaluating prior queryables. However, there are
//TODO:    a few things I need to be careful of and watch out for:
//TODO:         - If the evaluation of a queryable causes all prior queryable&#039;s to also be evaluated, then it would make sense to &#039;save&#039; the evaluation
//TODO:           of each queryable along the pipeline. If I evaluate a prior queryable during the evaluation of the &#039;final&#039; queryable, but fail to &#039;save&#039;
//TODO:           that evaluation in the prior queryable object, then, if that prior queryable is ever iterated again, I&#039;ll have to perform the work all
//TODO:           over again. So, I probably need to pass some context into each of the queryable&#039;s function iterators so they can &#039;save&#039; the evaluated
//TODO:           data in that queryable object should it be iterated again at some future point (this assumes a non-streaming context). This would also
//TODO:           mean that I&#039;d need to check to see if the current queryable has been evaluated within the iterator before performing the evaluation.
//TODO:
//TODO:         - Again, if the evaluation of a queryable causes all prior queryable&#039;s in the pipeline to also be evaluated, how do I handle a split
//TODO:           queryable pipeline? Example:
//TODO:                 var a = new[] {1, 2, 3, 4, 5};
//TODO:                 var b = a.Select(it =&gt; it * 2);
//TODO:                 var c = b.Where(it =&gt; it % 2 == 0);
//TODO:                 var d = c.Join(new [] {2, 4, 6, 8, 10},
//TODO:                             it =&gt; it,
//TODO:                             item  =&gt; item
//TODO:                             (it, item) =&gt; it * item);
//TODO:                 var e = c.Join(new[] {1, 2, 3, 4, 5},
//TODO:                             it =&gt; it,
//TODO:                             item =&gt; item
//TODO:                             (it, item) =&gt; it * item);
//TODO:
//TODO:           Here, if the &#039;d&#039; queryable is evaluated, then the &#039;c&#039; and &#039;b&#039; queryables will also be evaluated. So, if the &#039;e&#039; queryable is later
//TODO:           evaluated, it needs to be able to grab the pre-evaluated data from &#039;b&#039; and &#039;c&#039; rather than re-evaluating them again. Given my proposed
//TODO:           method of dealing with prior queryable evaluation above, the &#039;e&#039; queryable object would probably benefit from that &#039;saved&#039; evaluation
//TODO:           state as well. But this is something to be aware of as I don&#039;t want to re-perform work that has already been done.
//TODO:
//TODO:         - While there won&#039;t be any concept of &#039;tasks&#039; in this library any time soon (or possible never), introducing tasks adds a whole new
//TODO:           dimension to queryable evaluation and the saving of that evaluation. Besides which, even if I don&#039;t use web workers or some other
//TODO:           JavaScript threading technology, if I am using generators in this library, it is only fair to assume that consumers of this library
//TODO:           are also using generators. While generators do not provide true synchronous execution, they can mimic it at the program level. This
//TODO:           means, again, using the example code above, that both &#039;d&#039; and &#039;e&#039; could be evaluated at the &#039;same&#039; time. Because a queryable object&#039;s
//TODO:           iterator is a generator, both &#039;d&#039; and &#039;e&#039; would have their own &#039;instance&#039; of the &#039;b&#039; and &#039;c&#039; iterators; so there should be no issue
//TODO:           with race conditions per se. But, if each iterator is checking its queryable&#039;s state to see if it has already been evaluated before
//TODO:           performing the evaluation, this could lead to some interesting effects. It could also happen that the &#039;c&#039; and &#039;d&#039; queryable objects
//TODO:           are being evaluated at the &#039;same&#039; time. Which I think would be even more likely to cause issue since &#039;c&#039; is 100% within the &#039;d&#039;
//TODO:           queryable&#039;s pipeline.
//TODO:
//TODO:         - In the interest of allow for easy extensibility, I should probably wrap each deferred execution &#039;method&#039;s&#039; returned iterator
//TODO:           in a generator function before setting it as the new queryable object&#039;s iterator. The wrapper would be where it would check the queryable
//TODO:           object&#039;s state to see if it has already been evaluated before actually performing the evaluation. This would allow users of the library
//TODO:           to focus more on the evaluation logic of their function via the iterator without having to worry about checking if the queryable has
//TODO:           already been evaluated, while at the same time, providing a clean and consistent &#039;interface&#039; for a queryable&#039;s [Symbol.iterator] property.
//TODO:           In addition, the iterator wrapper could always set the queryable&#039;s evaluated state after the function iterator has completed execution as
//TODO:           well. This way, not only does a function&#039;s iterator not need to check if the queryable object it is iterating has already been evaluated,
//TODO:           but it also won&#039;t need to bother setting that state once it completes the evaluation as it will be performed in the iterator wrapper. Now,
//TODO:           each function&#039;s iterator is free to concern itself solely with its own evaluation and doesn&#039;t need to bother with the checking or setting
//TODO:           of a queryable&#039;s evaluated state, nor what to do when the queryable it is evaluating has already been evaluated.
//TODO:
//TODO:         - Finally, as mentioned above, &#039;saving&#039; the evaluated data of a queryable object kinda assumes a non-streaming version/usage of this library.
//TODO:           While I don&#039;t want to extend my focus on more than is necessary to implement the core functionality, I think this library would be
//TODO:           significantly more useful if it could handle both finite and potentially infinite (i.e. streaming) sets. The problem is that the concept
//TODO:           of a &#039;pre-evaluated&#039; queryable is ridiculous in a streaming context. Obviously, I could take the hacky way out and just create two
//TODO:           separate queryable object types; one for finite sets, and one for potentially infinite sets. But, not only is that hacky, ugly, and just
//TODO:           plain lazy, but I also feel it reduces the usability practicality of this library if a user must learn not one, but two APIs for the
//TODO:           two queryable objects, and when to use each one. In general, it is sacrificing consumer convenience for developer convenience, and I
//TODO:           just won&#039;t stand for it!
//TODO:
//TODO: 4) Every queryable collation &#039;method&#039; should be capable of taking any enumerable object as an argument for the &#039;collection&#039; parameter, including
//TODO:    another queryable object. Utilizing generators and for-of loops should make this very possible. Only objects that have an iterator, built-in or
//TODO:    otherwise, should be accepted. An object without an iterator, although enumerable, should not be accepted as a valid parameter. In light of this,
//TODO:    I should probably change the &#039;collection&#039; parameter in all collation &#039;methods&#039; to &#039;enumerable&#039; or something similar.


function union(source, collection, comparer) {
    comparer = comparer || defaultEqualityComparer;
    var havePreviouslyViewed = memoizer2(comparer);

    return function *unionIterator() {
        var res;
        for (let item of source) {
            res = havePreviouslyViewed(item);
            if (!res) yield item;
        }

        for (let item of collection) {
            res = havePreviouslyViewed(item);
            if (!res) yield item;
        }
    };
}

export { union };</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>

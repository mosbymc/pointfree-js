interface list<T> extends IMonad<T> {
    apply(l: list<(arg: T) => any>): list<any>;
    chain(fn: (x: T) => list<any>): list<any>;
    concat(ys: Iterable): list<any>;
    concatAll(...ys: Array<Iterable>): list<any>;
    contramap(fn: (x: any) => T): list<T>;
    copyWithin(index: number): list<T>;
    copyWithin(index: number, start: number): list<T>;
    copyWithin(index: number, start: number, end: number): list<T>;
    dimap(f: (x: any) => T, g: (x: T) => any): list<any>;
    distinct(): list<T>;
    distinct(comparer: (x: T, y: T) => boolean): list<T>;
    except(xs: Iterable): list<T>;
    except(xs: Iterable, comparer: (x: T, y: T) => boolean): list<T>;
    fill(value: T): list<T>;
    fill(value: T, start: number): list<T>;
    fill(value: T, start: number, end: number): list<T>;
    filter(predicate: (x: T) => boolean): list<T>;
    groupBy(keySelector: (x: T) => any): list<T>;
    groupBy(keySelector: (x: T) => any, comparer: (x: any, y: any) => boolean): list<T>;
    groupByDescending(keySelector: (x: T) => any): list<T>;
    groupByDescending(keySelector: (x: T) => any, comparer: (x: any, y: any) => boolean): list<T>;
    groupJoin(ys: Iterable, xSelector: (x: T) => any, ySelector: (y: T) => any, projector: (x: any, y: any) => any): list<any>;
    groupJoin(ys: Iterable, xSelector: (x: T) => any, ySelector: (y: T) => any, projector: (x: any, y: any) => any, comparer: (x: any, y: any) => boolean): list<any>;
    head(): list<T>;
    intersect(xs: Iterable): list<T>;
    intersect(xs: Iterable, comparer: (x: T, y: T) => boolean): list<T>;
    intersperse(val: T): list<T>;
    listJoin(ys: Iterable, xSelector: (x: any) => any, ySelector: (y: any) => any, projector: (x: any, y: any) => any): list;
    listJoin(ys: Iterable, xSelector: (x: any) => any, ySelector: (y: any) => any, projector: (x: any, y: any) => any, comparer: (x: any, y: any) => boolean): list;
    map(fn: (x: T) => any): list<any>;
    join(): list<T>;
    ofType(type: string): list<T>;
    ofType(type: {}): list<T>;
    pop(): list<T>;
    prepend(xs: Iterable): list;
    prependAll(...xs: Array<Iterable>): list;
    push(...items: Array<any>): list<T>;
    reverse(): list<T>;
    shift(): list<T>;
    skip(amt: number): list<T>;
    skipWhile(predicate: (x: T) => boolean): list<T>;
    slice(start: number): list<T>;
    slice(start: number, end: number): list<T>;
    sortBy(): ordered_list<T>;
    sortBy(keySelector: (x: T) => any): ordered_list<T>;
    sortBy(keySelector: (x: T) => any, comparer: (x: any, y: any) => boolean): ordered_list<T>;
    sortByDescending(): ordered_list<T>;
    sortByDescending(keySelector: (x: T) => any): ordered_list<T>;
    sortByDescending(keySelector: (x: T) => any, comparer: (x: any, y: any) => boolean): ordered_list<T>;
    splice(start: number): list<T>;
    splice(start: number, end: number): list<T>;
    tail(): list<T>;
    take(amt: number): list<T>;
    takeWhile(predicate: (x: T) => boolean): list<T>;
    union(xs: Iterable): list<any>;
    union(xs: Iterable, comparer: (x: T, y: any) => boolean): list<any>;
    unshift(...xs: Array<any>): list<T>;
    zip(selector: (x: T) => any, xs: Iterable): list<any>;
    all(): boolean;
    all(predicate: (x: T) => boolean): boolean;
    any(): boolean;
    any(predicate: (x: T) => boolean): boolean;
    contains(val: any): boolean;
    contains(val: any, comparer: (x: T, y: any) => boolean): boolean;
    count(): number;
    count(predicate: (x: T) => boolean): number;
    equals(f: list, comparer: (x: T, y: any) => boolean): boolean;
    findIndex(comparer: (x: T) => boolean): number;
    findLastIndex(comparer: (x: T) => boolean): number;
    first(): T;
    first(predicate: (x: T) => boolean): any;
    foldl(fn: (x: T, accumulator: any) => any, acc: any): T;
    foldr(fn: (x: T, accumulator: any) => any, acc: any): T;
    forEach(fn: (x: T) => void): this;
    indexOf(val: any): number;
    isEmpty(): boolean;
    arrayJoin(): string;
    arrayJoin(delimiter: string): string;
    last(): T;
    last(predicate: (x: T) => boolean): T;
    reduceRight(fn: (x: T, accumulator: any) => any): any;
    reduceRight(fn: (x: T, accumulator: any) => any, acc: any): any;
    toArray(): Array<T>;
    toEvaluatedList(): list<T>;
    toMap(): Map<T>;
    toMap(fn: (item: T, idx: number) => Array<any, any>): Map<T>;
    toSet(): Set<T>;
    toString(): string;
    toLocaleString(): string;
    toJSON(): string;
    set(idx: number, val: any): list<T>;
    get(idx: number): T;
    factory: List;
    data: Array<T>;
    extract: Array<T>;
}

interface ordered_list<T> extends IMonad<T> {
    apply(l: list<(arg: T) => any>): list<any>;
    chain(fn: (x: T) => list): list<T>;
    concat(ys: Iterable): list<any>;
    concatAll(...ys: Array<Iterable>): list<any>;
    contramap(fn: (x: T) => any): list<T>;
    copyWithin(index: number): list<any>;
    copyWithin(index: number, start: number): list<any>;
    copyWithin(index: number, start: number, end: number): list<any>;
    dimap(f: (x: any) => T, g: (x: T) => any): list<any>;
    distinct(): list<T>;
    distinct(comparer: (x: T, y: T) => boolean): list<T>;
    except(xs: Iterable): list<T>;
    except(xs: Iterable, comparer: (x: T, y: any) => boolean): list<T>;
    fill(value: any): list<any>;
    fill(value: any, start: number): list<any>;
    fill(value: any, start: number, end: number): list<any>;
    filter(predicate: (x: T) => boolean): list<T>;
    groupBy(keySelector: (x: T) => any): list<T>;
    groupBy(keySelector: (x: T) => any, comparer: (x: any, y: any) => boolean): list<T>;
    groupByDescending(keySelector: (x: T) => any): list<T>;
    groupByDescending(keySelector: (x: T) => any, comparer: (x: any, y: any) => boolean): list<T>;
    groupJoin(ys: Iterable, xSelector: (x: T) => any, ySelector: (y: T) => any, projector: (x: any, y: any) => any): list<T>;
    groupJoin(ys: Iterable, xSelector: (x: T) => any, ySelector: (y: T) => any, projector: (x: any, y: any) => any, comparer: (x: any, y: any) => boolean): list<T>;
    head(): list<T>;
    intersect(xs: Iterable): list<T>;
    intersect(xs: Iterable, comparer: (x: T, y: any) => boolean): list<T>;
    intersperse(val: any): list<any>;
    listJoin(ys: Iterable, xSelector: (x: T) => any, ySelector: (y: any) => any, projector: (x: any, y: any) => any): list<any>;
    listJoin(ys: Iterable, xSelector: (x: T) => any, ySelector: (y: any) => any, projector: (x: any, y: any) => any, comparer: (x: any, y: any) => boolean): list<any>;
    map(fn: (x: T) => any): list<T>;
    join(): list<T>;
    ofType(type: string): list<T>;
    ofType(type: {}): list<T>;
    pop(): list<T>;
    prepend(xs: Iterable): list<T>;
    prependAll(...xs: Array<Iterable>): list<T>;
    push(...items: Array<any>): list<T>;
    reverse(): list<T>;
    shift(): list<T>;
    skip(amt: number): list<T>;
    skipWhile(predicate: (x: T) => boolean): list<T>;
    slice(start: number): list<T>;
    slice(start: number, end: number): list<T>;
    thenBy(): ordered_list<T>;
    thenBy(keySelector: (x: T) => any): ordered_list<T>;
    thenBy(keySelector: (x: T) => any, comparer: (x: any, y: any) => boolean): ordered_list<T>;
    thenByDescending(): ordered_list<T>;
    thenByDescending(keySelector: (x: T) => any): ordered_list<T>;
    thenByDescending(keySelector: (x: T) => any, comparer: (x: any, y: any) => boolean): ordered_list<T>;
    splice(start: number): list<T>;
    splice(start: number, end: number): list<T>;
    tail(): list<T>;
    take(amt: number): list<T>;
    takeWhile(predicate: (x: T) => boolean): list<T>;
    union(xs: Iterable): list<T>;
    union(xs: Iterable, comparer: (x: T, y: any) => boolean): list<T>;
    unshift(...xs: Array<any>): list<T>;
    zip(selector: (x: T) => any, xs: Iterable): list<T>;
    all(): boolean;
    all(predicate: (x: T) => boolean): boolean;
    any(): boolean;
    any(predicate: (x: T) => boolean): boolean;
    contains(val: any): boolean;
    contains(val: any, comparer: (x: T, y: any) => boolean): boolean;
    count(): number;
    count(predicate: (x: T) => boolean): number;
    equals(f: list, comparer: (x: T, y: any) => boolean): boolean;
    findIndex(comparer: (x: T) => boolean): number;
    findLastIndex(comparer: (x: T) => boolean): number;
    first(): T;
    first(predicate: (x: T) => boolean): any;
    foldl(fn: (x: T, accumulator: any) => any, acc: any): any;
    foldr(fn: (x: T, accumulator: any) => any, acc: any): any;
    forEach(fn: (x: T) => void): this;
    indexOf(val: any): number;
    isEmpty(): boolean;
    arrayJoin(): string;
    arrayJoin(delimiter: string): string;
    last(): T;
    last(predicate: (x: T) => boolean): any;
    reduceRight(fn: (x: T, accumulator: any) => any): any;
    reduceRight(fn: (x: T, accumulator: any) => any, acc: any): any;
    toArray(): Array<T>;
    toEvaluatedList(): list<T>;
    toMap(): Map;
    toMap(fn: (item: T, idx: number) => Array<any, any>): Map<T>;
    toSet(): Set;
    toString(): string;
    toLocaleString(): string;
    toJSON(): string;
    set(idx: number, val: any): list<T>;
    get(idx: number): any;
    factory: List;
    data: Array<T>;
    extract: Array<T>;
}

interface List<T> {
    (source: T): list<T>;
    from(...source: Array<T>): list<T>;
    ordered(source: Iterable, selector: (x: T) => T): list<T>;
    ordered(source: Iterable, selector: (x: T) => T, comparer: (x: T, y: T) => boolean): ordered_list<T>;
    empty(): ordered_list;
    just(val: T): ordered_list<T>;
    unfold(fn: (val: any) => { next: any, value: any, done: boolean }, seed: any): list;
    is(x: any): boolean;
    repeat(item: T, count: number): list<T>;
    extend(prop: string, fn: (...x: Array<any>) => () => any): void;
}